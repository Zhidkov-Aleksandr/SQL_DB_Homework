# SQL_DB_Homework
Homework on SQL databases

1. Транспортные средства
Задача 1

Результат выполнения запроса:
maker	model
Yamaha	YZF-R1
Пояснение:
JOIN таблиц: Соединяем Vehicle и Motorcycle по полю model, чтобы получить данные о производителе.

Фильтрация:

horsepower > 150 — мощность больше 150 л.с.

price < 20000 — цена менее 20 000 долларов.

type = 'Sport' — тип мотоцикла «Спортивный».

Сортировка: Результаты упорядочены по убыванию мощности (DESC).

Проверка на примере данных:
Из вставленных мотоциклов только Yamaha YZF-R1 удовлетворяет всем условиям:

Мощность 200 л.с. (>150)

Цена 17 000
(
<
20000
(<20000)

Тип «Sport».


1. Транспортные средства
Задача 2


Результат выполнения запроса:
maker	model	horsepower	engine_capacity	type
Toyota	Camry	203	2.50	Car
Yamaha	YZF-R1	200	1.00	Motorcycle
Trek	Domane	NULL	NULL	Bicycle





Пояснение:
Для автомобилей (Car):

Выбрана Toyota Camry (203 л.с., 2.5 л)

Ford Mustang исключен из-за объема двигателя 5.0 л

Honda Civic исключен из-за мощности 158 л.с.

Для мотоциклов (Motorcycle):

Выбран Yamaha YZF-R1 (200 л.с., 1.0 л)

Kawasaki Ninja исключен из-за мощности 150 л.с.

Для велосипедов (Bicycle):

Выбран Trek Domane (22 передачи)

Specialized Stumpjumper исключен из-за цены 4000$

Сортировка:

Сначала транспорт с указанной мощностью (по убыванию)

Велосипеды в конце списка

2 . Автомобильные гонки 
Задача 1

Результат выполнения запроса:
maker	model	horsepower	engine_capacity	type
Toyota	Camry	203	2.50	Car
Yamaha	YZF-R1	200	1.00	Motorcycle
Trek	Domane	NULL	NULL	Bicycle
Пояснение:
Для автомобилей (Car):

Выбрана Toyota Camry (203 л.с., 2.5 л)

Ford Mustang исключен из-за объема двигателя 5.0 л

Honda Civic исключен из-за мощности 158 л.с.

Для мотоциклов (Motorcycle):

Выбран Yamaha YZF-R1 (200 л.с., 1.0 л)

Kawasaki Ninja исключен из-за мощности 150 л.с.

Для велосипедов (Bicycle):

Выбран Trek Domane (22 передачи)

Specialized Stumpjumper исключен из-за цены 4000$

Сортировка:

Сначала транспорт с указанной мощностью (по убыванию)

Велосипеды в конце списка

2 . Автомобильные гонки 
Задача 2

Результат выполнения запроса:
car_name	class	country	avg_position	races_count
Ferrari 488	Convertible	Italy	1.00	1
Пояснение:
CTE CarStats:

Рассчитывает среднюю позицию и количество гонок для каждого автомобиля

Использует JOIN между Cars и Results

Группирует по имени автомобиля и классу

Основной запрос:

Добавляет информацию о стране из таблицы Classes

Сортирует результаты:

Сначала по средней позиции (от лучшей к худшей)

Затем по имени автомобиля (на случай одинаковых позиций)

Выбирает первую запись с помощью LIMIT 1

Особенности:

Округление средней позиции до 2 знаков

Учитываются только автомобили, участвовавшие в гонках

Гарантированно возвращает один результат даже при совпадении позиций

2 . Автомобильные гонки 
Задача 3


Объяснение:
CTE CarStats:

Рассчитывает для каждого автомобиля:

Среднюю позицию (AVG(position))

Количество гонок (COUNT(race))

Страну производства (из таблицы Classes)

Общее количество гонок в классе (SUM OVER PARTITION)

CTE MinClassPosition:

Находит минимальную среднюю позицию для каждого класса

Основной запрос:

Соединяет статистику автомобилей с минимальными позициями классов

Форматирует вывод с 4 знаками после запятой

Сортирует по средней позиции и имени автомобиля

Результат для тестовых данных:
car_name	car_class	average_position	race_count	car_country	total_races
Ferrari 488	Convertible	1.0000	1	Italy	1
Ford Mustang	SportsCar	1.0000	1	USA	1
Особенности решения:
Учитывает все классы с одинаковой минимальной позицией

Правильно считает общее количество гонок для класса

Сохраняет возможность отображения нескольких автомобилей в классе

Гарантирует точность до 4 знаков после запятой

Соответствует требуемому формату вывода

2 . Автомобильные гонки 
Задача 4


Результат выполнения:
car_name	car_class	average_position	race_count	car_country
BMW 3 Series	Sedan	3.0000	1	Germany
Toyota RAV4	SUV	2.0000	1	Japan
Объяснение:
CTE ClassStats:

Рассчитывает для каждого класса:

Среднюю позицию всех автомобилей (class_avg_position)

Количество автомобилей в классе (cars_in_class)

CTE CarPerformance:

Собирает данные по каждому автомобилю:

Средняя позиция автомобиля

Количество участий в гонках

Страна производства

Средняя позиция класса

Количество авто в классе

Фильтрация:

avg_position < class_avg_position - позиция авто лучше средней по классу

cars_in_class >= 2 - в классе минимум 2 автомобиля

Сортировка:

По названию класса (алфавитный порядок)

По средней позиции (от лучшей к худшей)

Особенности решения:
Использование оконных функций для расчета статистики по классу

Точное сравнение позиций с 4 знаками после запятой

Исключение классов с одним автомобилем

Соответствие формату вывода из условия задачи


2 . Автомобильные гонки 
Задача 5

Объяснение:
CTE CarStats:

Собирает статистику по каждому автомобилю:

Средняя позиция (AVG(position))

Количество гонок (COUNT(race))

Страна производства (cl.country)

Общее количество гонок в классе (COUNT(*) OVER PARTITION)

CTE LowPositionCars:

Находит классы с максимальным количеством автомобилей, у которых avg_position > 3.0

Использует подзапрос для поиска максимального значения

Основной запрос:

Фильтрует автомобили с avg_position > 3.0

Соединяет с классами-лидерами

Форматирует вывод с 4 знаками после запятой

Сортирует по количеству автомобилей с низкой позицией, затем по классу и позиции

Результат для тестовых данных:
car_name	car_class	average_position	race_count	car_country	total_races	low_position_count
Audi A4	Sedan	8.0000	1	Germany	2	2
Chevrolet Camaro	Coupe	4.0000	1	USA	1	1
Renault Clio	Hatchback	5.0000	1	France	1	1
Ford F-150	Pickup	6.0000	1	USA	1	1
Особенности:
Точное соответствие формату вывода

Корректный подсчет total_races для класса

Выбор только классов с максимальным low_position_count

Сортировка по требуемым критериям

3 . Бронирование отелей
Задача 1


Объяснение:
Соединение таблиц:

Customer → Booking → Room → Hotel

Агрегация данных:

COUNT(b.ID_booking) — общее количество бронирований клиента

GROUP_CONCAT(DISTINCT h.name) — список уникальных отелей через запятую

AVG(DATEDIFF(...)) — средняя длительность пребывания

Фильтрация:

COUNT(DISTINCT h.ID_hotel) >= 2 — бронирования в ≥2 разных отелях

COUNT(b.ID_booking) > 2 — более 2 бронирований

Сортировка:

По убыванию количества бронирований

Результат:
customer_name	email	phone	total_bookings	hotels	avg_duration
Bob Brown	bob.brown@example.com	+2233445566	3	Grand Hotel, Ocean View Resort	3.0000
Ethan Hunt	ethan.hunt@example.com	+5566778899	3	Mountain Retreat, Ocean View Resort	3.0000
Проверка:
Bob Brown:

Бронирования: 4 (Ocean View), 13 (Grand), 23 (Grand) → 3 бронирования, 2 отеля

Средняя длительность: (4 + 2 + 3) / 3 = 3.0

Ethan Hunt:

Бронирования: 7 (Mountain), 16 (Ocean), 26 (Ocean) → 3 бронирования, 2 отеля

Средняя длительность: (4 + 2 + 3) / 3 = 3.0


3 . Бронирование отелей
Задача 2


Результат:

ID_customer	name	total_bookings	total_spent	unique_hotels
4	Bob Brown	3	820.00	2
7	Ethan Hunt	3	850.00	2
Пояснение:

MultiHotelClients CTE:

Находит клиентов с >2 бронированиями в >1 отеле.

Считает общую сумму бронирований как SUM(r.price).

HighSpendingClients CTE:

Находит клиентов с общей суммой бронирований >500$.

Объединение результатов:

INNER JOIN по ID_customer для выбора клиентов, удовлетворяющих обоим условиям.

Сортировка по возрастанию общей суммы.

Проверка данных:

Bob Brown: 3 бронирования (номера 4,3,3) → 120 + 350 + 350 = 820$

Ethan Hunt: 3 бронирования (номера 7,6,6) → 250 + 300 + 300 = 850$

3 . Бронирование отелей
Задача 3

Объяснение запроса:
HotelCategory :
Вычисляем среднюю стоимость номеров для каждого отеля (AVG(r.price)).
Присваиваем категорию отеля на основе средней стоимости: «Дешевый», «Средний» или «Дорогой».
CustomerPreferences :
Для каждого клиента определяем категории отелей, которые он посещал.
Используем MAX для определения приоритета предпочтений («Дорогой» > «Средний» > «Дешевый»).
Формируем список уникальных отелей, которые посетил клиент, используя GROUP_CONCAT.
FinalResult :
Преобразуем числовые приоритеты в текстовые категории («Дешевый», «Средний», «Дорогой»).
Итоговый SELECT :
Сортируем клиентов по предпочитаемым категориям в порядке: «Дешевый», «Средний», «Дорогой».
Если у клиентов одинаковая категория, сортируем по ID_customer.
Результат для тестовых данных:
plaintext
Копировать
1
2
3
4
5
6
7
8
9
10
11
12
ID_customer | name             | preferred_hotel_type | visited_hotels
------------|------------------|----------------------|-----------------------------
10          | Hannah Montana   | Дешевый             | City Center Inn
1           | John Doe         | Средний             | City Center Inn,Grand Hotel
2           | Jane Smith       | Средний             | Grand Hotel
3           | Alice Johnson    | Средний             | Grand Hotel
4           | Bob Brown        | Средний             | Grand Hotel,Ocean View Resort
5           | Charlie White    | Средний             | Ocean View Resort
6           | Diana Prince     | Средний             | Ocean View Resort
7           | Ethan Hunt       | Дорогой             | Mountain Retreat,Ocean View Resort
8           | Fiona Apple      | Дорогой             | Mountain Retreat
9           | George Washington| Дорогой             | City Center Inn,Mountain Retreat
Пояснение результата:
Клиенты с категорией «Дешевый» (например, Hannah Montana) посещали только дешевые отели.
Клиенты с категорией «Средний» (например, John Doe, Jane Smith) посещали отели средней стоимости.
Клиенты с категорией «Дорогой» (например, Ethan Hunt, Fiona Apple) посещали хотя бы один дорогой отель.
Клиенты отсортированы по категориям, а затем по ID_customer.




4 . Структура организации
Задача 1




Объяснение запроса:

Этот SQL-запрос рекурсивно находит всех сотрудников, которые прямо или косвенно подчиняются Ивану Иванову (EmployeeID = 1), и выводит информацию о них. Разберем его по частям:

Рекурсивная часть (WITH RECURSIVE):

sql
Copy
WITH RECURSIVE Subordinates AS (...)
Базовый случай: Выбирает самого Ивана Иванова (WHERE EmployeeID = 1)

Рекурсивный шаг: На каждой итерации добавляет сотрудников, чей ManagerID совпадает с EmployeeID из предыдущего шага

Результат сохраняется во временной таблице Subordinates

Основной SELECT:

sql
Copy
SELECT 
    s.EmployeeID,
    s.Name AS EmployeeName,
    s.ManagerID,
    d.DepartmentName,
    r.RoleName,
    ...
Соединяет результаты с таблицами Departments и Roles для получения названий отделов и ролей

Проекты (ProjectNames):

sql
Copy
(SELECT GROUP_CONCAT(p.ProjectName ...) AS ProjectNames
Для каждого сотрудника собирает все проекты его отдела (по DepartmentID) в строку через запятую

Использует ORDER BY для сортировки названий проектов

Задачи (TaskNames):

sql
Copy
(SELECT GROUP_CONCAT(t.TaskName ...) AS TaskNames
Для каждого сотрудника собирает все задачи, где он указан в AssignedTo

Объединяет названия задач через запятую

Сортировка:

sql
Copy
ORDER BY EmployeeName
Фильтрует результаты по алфавиту имен сотрудников

Особенности:

Все подчиненные любого уровня вложенности включаются благодаря рекурсии

Если у сотрудника нет проектов/задач, возвращается NULL

GROUP_CONCAT используется для объединения строк

Неявно предполагается, что сотрудник связан с проектами через отдел, а не напрямую

Потенциальные проблемы:

Проекты выводятся по отделу сотрудника, а не по его прямым назначениям

Нет фильтрации дубликатов в GROUP_CONCAT

Используется INNER JOIN для Departments/Roles (сотрудники без отдела/роли не будут показаны)

Запрос соответствует поставленной задаче, но структура данных (особенно связь Projects с DepartmentID) может влиять на логику вывода проектов.




4 . Структура организации
Задача 2



Объяснение решения:

Рекурсивный CTE (Subordinates):

Начинаем с Ивана Иванова (EmployeeID = 1)

Рекурсивно добавляем всех сотрудников, чей ManagerID совпадает с EmployeeID из предыдущего уровня

Добавлен столбец Level для контроля глубины рекурсии (не используется в финальном выводе)

Основной SELECT:

ProjectNames: Все проекты отдела сотрудника через запятую (GROUP_CONCAT)

TaskNames: Все задачи сотрудника через запятую с сохранением порядка добавления (ORDER BY TaskID)

TotalTasks: Количество задач сотрудника (COUNT)

TotalSubordinates: Количество прямых подчиненных (COUNT сотрудников с данным ManagerID)

Сортировка:

Результаты упорядочены по имени сотрудника (ORDER BY s.Name)

Особенности реализации:

Для задач сохранен оригинальный порядок через сортировку по TaskID

Все связи проверяются через коррелированные подзапросы

Гарантирован полный вывод иерархии подчинения

Оптимизированная работа с NULL значениями



4 . Структура организации
Задача 3




Объяснение решения:

Рекурсивный CTE (ManagerSubordinates):

Находим всех менеджеров по названию роли

Рекурсивно собираем всех подчиненных (включая косвенных)

Для каждого менеджера сохраняем цепочку подчинения

Основной запрос:

Соединяем сотрудников с отделами и ролями

Считаем проекты отдела через GROUP_CONCAT

Собираем задачи сотрудника с сохранением порядка

Вычисляем общее количество подчиненных (COUNT - 1 для исключения самого менеджера)

Фильтрация:

HAVING отсеивает менеджеров без подчиненных

WHERE гарантирует выбор только сотрудников с ролью "Менеджер"

Особенности:

Использование DISTINCT в COUNT для исключения дубликатов

Явная фильтрация по названию роли вместо RoleID

Сохранение порядка задач через сортировку по TaskID

Решение работает для многоуровневой иерархии подчинения

